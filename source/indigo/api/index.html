<h1 id="api">API</h1>

<p><strong><a href="TODO:indigo-doc">New documentation (work in progress)</a></strong></p>

<h2 id="overview">Overview</h2>

<p>This page describes the API of Indigo library and its rendering plugin. The API allows developers to integrate Indigo into their C/Java/C#/Python projects. Please note that Indigo is under active development, and  can always post your <a href="../../contact.html#feedback-on-open-source-software">comments and suggestions</a> to our team.</p>

<h2 id="system">System</h2>

<p>Indigo acts like a state machine that consists of:</p>

<ul>
<li>Objects</li>
<li>Configuration settings</li>
<li>Error handling facility</li>
</ul>

<p>It is possible to use more than one Indigo instance at a time. In plain C API, the "active" instance can be switched with <code>indigoSetSession</code> call, while in Python, Java, and C#, the instance is represented as an object of class <code>Indigo</code>.</p>

<p>The objects that belong to the Indigo state machine are represented as integer handles in the C API, while in  Python, Java, and C# they are wrapped by the <code>IndigoObject</code> class.</p>

<p>Access to configuration settings is done via <code>indigoSetOption***</code> functions in the C API, while in Python, Java, and C# a number of <code>Indigo.setOption</code> methods can accomplish it.</p>

<p>Error handling in C is done via return codes, <code>indigoGetLastError</code>, and <code>indigoSetErrorHandler</code>. In Python, Java, and C#, as soon as some Indigo function terminates with an error, an <code>IndigoException</code> is thrown.</p>

<p>Several library instances may be created to act simultaneously and independently. However,
each instance requires a certain amount of memory, and thus it is recommended to have as few instances as
possible.</p>

<p>It is allowable to have multiple Indigo instances within one program and even in different threads. However, using a single Indigo instance across multiple threads is prohibited.</p>

<p>From now on, only the Python, Java, and C# interfaces are explained. For those who are interested in plain C interface, please read the <a href="c.html">C API</a> page.</p>

<h2 id="indigo-constructor">Indigo Constructor</h2>

<p>Java:</p>

<pre><code>import com.ggasoftware.indigo.*;
...
Indigo indigo = new Indigo();
</code></pre>

<p>C#:</p>

<pre><code>using com.ggasoftware.indigo;
....
Indigo indigo = new Indigo();
</code></pre>

<p>Python:</p>

<pre><code>from indigo import *
...
indigo = Indigo()
</code></pre>

<p>Python will assume the Indigo binaries stored in the <code>lib</code> directory in the directory where <code>indigo.py</code> is located. In C# and Java, the binaries are unpacked automatically into the system temporary folder.</p>

<h2 id="getting-the-version-string">Getting the Version String</h2>

<p>You can use the <code>Indigo.version</code> method to get the string containing the Indigo library version number.</p>

<p>Java:</p>

<pre><code>System.out.println("Indigo version " + indigo.version());
</code></pre>

<p>C#:  <br>
</p>

<pre><code>System.Console.WriteLine("Indigo version " + indigo.version());
</code></pre>

<p>Python:</p>

<pre><code>print "Indigo version " + indigo.version()
</code></pre>

<h2 id="loading-molecules-and-query-molecules">Loading Molecules and Query Molecules</h2>

<p>The <code>Indigo</code> object provides methods for loading <a href="../concepts/index.html#molecules-and-query-molecules">molecules and query molecules</a> from: strings, <code>byte[]</code> buffers, and files. The input format is detected automatically, except for SMARTS expressions, for which there are special methods.</p>

<p>Java and C#:</p>

<pre><code>IndigoObject mol1 = indigo.loadMolecule("ONc1cccc1");
IndigoObject mol2 = indigo.loadMoleculeFromFile("structure.mol");
IndigoObject qmol1 = indigo.loadQueryMolecule("C1-C-C-C-1");
IndigoObject qmol2 = indigo.loadQueryMoleculeFromFile("query.mol");
IndigoObject qmol3 = indigo.loadSmarts("[N,n,O;!H0]");
IndigoObject qmol4 = indigo.loadSmartsFromFile("query.sma");
</code></pre>

<p>Python: the same with the <code>IndigoObject</code> omitted.</p>

<h2 id="instrumenting-molecules">Instrumenting Molecules</h2>

<p>You can programmatically add atoms and bonds to a molecule. Atoms can be added with the <code>addAtom</code> method of the molecule. This method  accepts an atom symbol (a string) &#8212; an element from the periodic table, or a pseudoatom. Similarly, bonds can be added by calling <code>addBond</code> method of an atom. This method accepts another atom and the order of the new bond. You can also create an empty molecule by calling the <code>createMolecule</code> method.</p>

<p>Java and C#:</p>

<pre><code>IndigoObject mol = indigo.createMolecule();
IndigoObject atom1 = mol.addAtom("C");
IndigoObject atom2 = mol.addAtom("C");
IndigoObject atom3 = mol.addAtom("C");
IndigoObject atom4 = mol.addAtom("C");
IndigoObject atom5 = mol.addAtom("C");
IndigoObject atom6 = mol.addAtom("N");
IndigoObject bond1 = atom1.addBond(atom2, 2);
IndigoObject bond2 = atom2.addBond(atom3, 2);
IndigoObject bond3 = atom3.addBond(atom4, 1);
IndigoObject bond4 = atom4.addBond(atom5, 2);
IndigoObject bond5 = atom5.addBond(atom6, 1);
IndigoObject bond6 = atom6.addBond(atom1, 2);
</code></pre>

<p>You can programmatically construct a query molecule via <code>createQueryMolecule</code> method.</p>

<p>Java and C#:</p>

<pre><code>IndigoObject qmol = indigo.createQueryMolecule()
IndigoObject a1 = qmol.addAtom("C")
IndigoObject a2 = qmol.addAtom("[#6]")
a2.addBond(a1, 1)
</code></pre>

<p>Python: the same with the <code>IndigoObject</code> omitted.</p>

<p>You can reset existing atom keeping its connections and stereo configuration using <code>IndigoObject.resetAtom</code> method. It accepts string representation of an atom in the SMILES (or SMARTS for the queries) notation:</p>

<pre><code>a.resetAtom("N")
</code></pre>

<p>To add R-sites or convert existing atom into R-site you can use <code>addRSite</code> and <code>setRSite</code> methods:</p>

<pre><code>atom = mol.addRSite("R3")
atom2.setRSite("R4")
</code></pre>

<h2 id="instrumenting-query-atoms">Instrumenting Query Atoms</h2>

<p>Each atom and bond in the query molecule represents as a logic expression of various properties. Inidgo support almost all constraints from the SMARTS specification. To alter existing contrains you can use the following methods:</p>

<ul>
<li><code>addConstraint(type, value)</code>  &#8212; adds a specified constraint using logical <code>and</code> operation. </li>
<li><code>addConstraintNot(type, value)</code> &#8212; adds a negation of a constraint</li>
<li><code>addConstraintOr(type, value)</code> &#8212; adds a constraint using logical <code>or</code> operation.</li>
<li><code>removeConstraints(type)</code>  &#8212; removed all constraints with a specified type.</li>
</ul>

<p>The following self-explaining integer constraint types are supported:</p>

<ul>
<li>"atomic-number"</li>
<li>"charge"</li>
<li>"isotope"</li>
<li>"radical"</li>
<li>"valence"</li>
<li>"connectivity"</li>
<li>"total-bond-order"</li>
<li>"hydrogens"</li>
<li>"substituents"</li>
<li>"ring"</li>
<li>"smallest-ring-size"</li>
<li>"ring-bonds"</li>
<li>"rsite-mask"</li>
<li>"rsite"</li>
</ul>

<p>Other constraints:</p>

<ul>
<li>"aromaticity" = "aliphatic" or "aromatic"</li>
<li>"smarts" &#8212; any single-atom SMARTS expression</li>
</ul>

<p>Code example:</p>

<pre><code>query = indigo.createQueryMolecule()
atom = q.addAtom("")
atom.addConstraint("substituents", "3")
atom.addConstraintNot("atomic-number", "16")
atom.addConstraint("smarts", "[$([#6]=[N+]=[N-]),$([#6-]-[N+]#[N])]")
</code></pre>

<h3 id="merging-molecules">Merging Molecules</h3>

<p>You can merge one molecule into another using the <code>merge</code> method of a molecule. This method accepts a molecule
that is to be merged into the first molecule, and returns a "mapping" object. You can call the <code>mapAtom</code> method
of the mapping object to know what is the (new) atom of the first molecule that was transferred from the second
molecule.</p>

<p>Java and C#:</p>

<pre><code>IndigoObject mol = indigo.loadMolecule("c1ccccc1");
IndigoObject mol2 = indigo.loadMolecule("ON");
IndigoObject mapping = mol.merge(mol2);
mapping.mapAtom(mol2.getAtom(0)).addBond(mol.getAtom(3), 1);
</code></pre>

<p>Python: the same with the <code>IndigoObject</code> omitted.</p>

<h3 id="removing-atoms-and-bonds-from-molecules">Removing Atoms and Bonds from Molecules</h3>

<p>You can call the <code>IndigoObject.remove</code> method on an atom or a bond to remove it from the molecule it belongs to. Also, if you want to remove many atoms at once, you can call <code>IndigoObject.removeAtoms</code> method, providing to it an array of indices of atoms that you want to remove.</p>

<h3 id="submolecules">Submolecules</h3>

<p>The <code>IndigoObject.createSubmolecule</code> method is applicable to a molecule or a query molecule. It accepts an array of atom indices and returns a new molecule containing the given atoms copied from the molecule, and the bonds between them.</p>

<p>Similarly, the <code>IndigoObject.createEdgeSubmolecule</code> method accepts two arrays &#8212; atom indices and bond indices &#8212; and returns a new molecule containing the given atoms and bonds copied from the molecule.</p>

<p>Indigo allowes to create a reference on a submolecule of a molecule with method <code>IndigoObject.getSubmolecule</code>. Such molecule can be later used for finding layout of a molecule part.</p>

<h2 id="accessing-molecules">Accessing Molecules</h2>

<h3 id="accessing-atoms-and-bonds">Accessing Atoms and Bonds</h3>

<p>The following methods can be applied to a molecule or query molecule:</p>

<ul>
<li><code>getAtom</code> &#8212; returns the atom by the given index.</li>
<li><code>getBond</code> &#8212; returns the bond by the given index.</li>
<li><code>iterateAtoms</code> &#8212; returns an iterator over atoms, including pseudoatoms and R-sites.</li>
<li><code>iteratePseudoatoms</code> &#8212; returns an iterator over pseudoatoms.</li>
<li><code>iterateRSites</code> &#8212; returns an iterator over R-sites.</li>
<li><code>iterateBonds</code> &#8212; returns an iterator over bonds.</li>
</ul>

<h3 id="getting-the-properties-of-atoms-and-bonds">Getting the Properties of Atoms and Bonds</h3>

<p>The following methods of a molecule's atom can be called to obtain information:</p>

<ul>
<li><code>atomicNumber</code> &#8212; returns zero if the atomic number is undefined or ambiguous. (happens only on queries). This method can not be applied to R-sites or pseudoatoms.</li>
<li><code>isotope</code> &#8212; returns the isotope value or zero if the atomic number is undefined or ambiguous. </li>
<li><code>degree</code> &#8212; returns explicit atom degree.</li>
<li><code>charge</code> &#8212; returns the chagre value or <code>null</code> if the charge is undefined (can happens only on queries).</li>
<li><code>explicitValence</code> &#8212; returns the explicit valence or <code>null</code> if there is no explicit valence.</li>
<li><code>radicalElectrons</code> &#8212; returns the number of radical electrons or <code>null</code> if the radical is undefined (can happen only on queries).</li>
<li><code>countHydrogens</code> &#8212; returns the total number of hydrogens connected to the atom (explicit+implicit). Can return <code>null</code> on query atoms where the number of hydrogens is not definitely known.</li>
<li><code>countImplicitHydrogens</code> &#8212;  returns the number of implicit hydrogens connected to the atom. Not applicable to query atoms.</li>
<li><code>valence</code> &#8212; returns the valence of the atom. Not applicable to query atoms.</li>
<li><code>isPseudoatom</code> &#8212; returns <code>true</code> if the atom is a pseudoatom, <code>false</code> otherwise.</li>
<li><code>isRSite</code> &#8212;  returns <code>true</code> if the atom is a pseudoatom, <code>false</code> otherwise.</li>
<li><code>symbol</code> &#8212; returns a string containing the atom symbol. It is either a symbol the periodic table ("C", "Na"), or a pseudoatom label ("Res"), or an R-site mark ("R1").</li>
<li><code>xyz</code> &#8212;returns an aray of three <code>float</code> numbers, which define the position of the atom.</li>
<li><code>singleAllowedRGroup</code>  &#8212; R-Group index allowed on R-Site (usually there is a single allowed index). This method can be applied exclusively to R-sites.</li>
</ul>

<p>The following <code>IndigoObject</code> methods can be applied to molecule's bonds:</p>

<ul>
<li><code>bondOrder</code> &#8212; returns 1/2/3 if the bond is a single/double/triple bond. Returns 4 if the bond is an aromatic bond. Returns zero if the bond is ambiguous (query bond).</li>
<li><code>source</code>  &#8212;  the atom from which the bond is going</li>
<li><code>destination</code>  &#8212;  the atom to which the bond is going</li>
<li><code>topology</code>  &#8212;  returns Indigo.RING or Indigo.CHAIN, depending on whether the bond is a ring bond or not. Returns zero if the bond is ambiguous (query bond).</li>
</ul>

<h3 id="modifying-atoms-and-bonds">Modifying Atoms and Bonds</h3>

<p>The following methods of a molecule's atom can be called to modify the atom:</p>

<ul>
<li><code>resetCharge</code></li>
<li><code>resetExplicitValence</code></li>
<li><code>resetIsotope</code></li>
<li><code>resetRadical</code></li>
<li><code>setCharge</code> &#8212; accepts an integer charge value</li>
<li><code>setIsotope</code> &#8212; accepts an integer isotope value </li>
<li><code>setXYZ</code> &#8212; accepts three float numbers (X, Y, Z)</li>
<li><code>setAttachmentPoint</code> &#8212; accepts an integer index of the attachment point (usually 1 or 2).</li>
<li><code>setBondOrder</code> &#8212; accepts an integer value (1/2/3/4 for single/double/triple/aromatic)</li>
</ul>

<h3 id="accessing-neighbor-atoms">Accessing Neighbor Atoms</h3>

<p>With <code>iterateNeighbors</code> method you can access the neighbors atoms of an atom. Also, these "neighbor" objects respond to the <code>bond</code> method, which returns the bond connecting the atom with the neighbor.</p>

<p>Java:</p>

<pre><code>for (IndigoObject atom : mol.iterateAtoms())
{
  System.out.printf("atom %d: %d neighbors\n", atom.index(), atom.degree());
  for (IndigoObject nei : atom.iterateNeighbors())
    System.out.printf("neighbor atom %d is connected by bond %d\n", nei.index(), nei.bond().index());
}
</code></pre>

<p>C#:  <br>
</p>

<pre><code>foreach (IndigoObject atom in mol.iterateAtoms())
{
  System.Console.WriteLine("atom {0}: {1} neighbors\n", atom.index(), atom.degree());
  foreach (IndigoObject nei in atom.iterateNeighbors())
    System.Console.WriteLine("neighbor atom {0} is connected by bond {1}\n", nei.index(), nei.bond().index());
}
</code></pre>

<p>Python:</p>

<pre><code>for atom in mol.iterateAtoms():
  print "atom %d: %d neighbors" % (atom.index(), atom.degree())
  for nei in atom.iterateNeighbors():
    print "neighbor atom %d is connected by bond %d\n" % (nei.index(), nei.bond().index())
</code></pre>

<h3 id="accessing-rgroups">Accessing R-Groups</h3>

<p><strong>Note</strong>: This section applies exclusively to query molecules.</p>

<p>The <code>iterateRGroups</code> method iterates over a query molecule's R-groups. Each of the R-groups has a collection of possible "R-group fragments", which in turn can be accessed via the <code>iterateRGroupFragments</code> method.</p>

<p>Java:</p>

<pre><code>for (IndigoObject rg : mol.iterateRGroups())
{
  System.out.println("RGROUP #" + rg.index());
  for (IndigoObject frag : rg.iterateRGroupFragments())
  {
     System.out.println("  FRAGMENT #" + rg.index());
     System.out.println(frag.molfile());
  }
}
</code></pre>

<p>C#:</p>

<pre><code>foreach (IndigoObject rg in mol.iterateRGroups())
{
  System.Console.WriteLine("RGROUP #" + rg.index());
  foreach (IndigoObject frag in rg.iterateRGroupFragments())
  {
     System.Console.WriteLine("  FRAGMENT #" + rg.index());
     System.Console.WriteLine(frag.molfile());
  }
}
</code></pre>

<p>Python:</p>

<pre><code>for rg in mol.iterateRGroups():
  print "RGROUP #" + rg.index()
  for frag in rg.iterateRGroupFragments():
     print "  FRAGMENT #" + rg.index()
     print frag.molfile()
</code></pre>

<h2 id="calculating-molecule-properties">Calculating Molecule Properties</h2>

<p>The following <code>IndigoObject</code> methods can be applied to a molecule or query molecule:</p>

<ul>
<li><code>countAtoms</code> &#8212; returns the number of atoms, including pseudoatoms and R-sites.</li>
<li><code>countPseudoatoms</code> &#8212; returns the number of pseudoatoms.</li>
<li><code>countRSites</code> &#8212; returns the number of R-sites.</li>
<li><code>coundBonds</code> &#8212; returns the number of bonds.</li>
<li><code>grossFormula</code> &#8212; returns a string with the gross formula.</li>
<li><code>molecularWeight</code> &#8212; returns the molecular weight (a floating-point number).</li>
<li><code>mostAbundantMass</code> &#8212; returns the "most abundant isotopes mass" (a floating-point number).</li>
<li><code>monoisotopicMass</code> &#8212; returns the monoisotopic mass (a floating-point number).</li>
<li><code>hasCoord</code>  &#8212; returns <code>true</code> if the given molecule has coordinates, <code>false</code> otherwise.</li>
<li><code>hasZCoord</code>  &#8212; returns <code>true</code> if the given molecule has 3D coordinates, <code>false</code> otherwise.</li>
<li><code>isChiral</code>  &#8212; returns <code>true</code> if the molecule was loaded from a Molfile, and if it had the 'Chiral' flag set.</li>
<li><code>countHeavyAtoms</code> &#8212; returns the number of atoms in the molecule, excluding hydrogen atoms. Hydrogen isotopes are excluded too.</li>
<li><code>countImplicitHydrogens</code> &#8212; returns the total number of implicit hydrogens in the molecule.</li>
<li><code>countHydrogens</code> &#8212; returns the total number of hydrogens in the molecule (implicit hydrogens included, hydrogen isotopes included).</li>
<li><code>countSSSR</code> &#8212; returns the total number of cycles in the Smallest Set of Smallest Rings (SSSR).</li>
</ul>

<h2 id="molecule-validation">Molecule Validation</h2>

<p>Molecule validation can be done using the following methods:</p>

<ul>
<li><code>checkBadValence</code></li>
<li><code>checkAmbiguousH</code></li>
</ul>

<p>These functions returns non-empty string description of found issues, or empty string if molecule is correct.</p>

<h2 id="working-with-connected-components">Working with Connected Components</h2>

<p>You can use the <code>countComponents</code> method to calculate the number of connected components in a structure. Via the <code>componentIndex</code> method, you can obtain the number of the component to which the given atom belongs. Also, you can obtain the whole "component" object via the <code>component</code> method. You can also iterate over the components using the <code>iterateComponents</code> method.</p>

<p>The "component" objects respond to the <code>countAtoms</code>, <code>countBonds</code>, <code>iterateAtoms</code>, and <code>iterateBonds</code> calls. However, they can not be used as molecules. If you want to have a separate molecule representing a connected component, you should <code>clone</code> it.</p>

<p><strong>Note:</strong> The numbering of the components in zero-based. </p>

<p>Java:</p>

<pre><code>System.out.printf("%d components\n", mol.countComponents());

for (IndigoObject comp : mol.iterateComponents())
{
   System.out.println(comp.clone().smiles());
   System.out.printf("component %d: %d atoms, %d bonds\n", comp.index(), comp.countAtoms(), comp.countBonds());

   for (IndigoObject atom : comp.iterateAtoms())
      System.out.println(atom.index());

}

for (IndigoObject atom : mol.iterateAtoms())
   System.out.println(atom.componentIndex());

for (IndigoObject atom : mol.component(0).iterateAtoms())
   System.out.println(atom.index());
</code></pre>

<p>C#:</p>

<pre><code>System.Console.WriteLine("{0} components", mol.countComponents());

foreach (IndigoObject comp in mol.iterateComponents())
{
   System.Console.WriteLine(comp.clone().smiles());
   System.Console.WriteLine("component {0}: {0} atoms, {0} bonds\n", comp.index(), comp.countAtoms(), comp.countBonds());
   foreach (IndigoObject atom in comp.iterateAtoms())
      System.Console.WriteLine(atom.index());

}

foreach (IndigoObject atom in mol.iterateAtoms())
   System.Console.WriteLine(atom.componentIndex());

foreach (IndigoObject atom in mol.component(0).iterateAtoms())
   System.Console.WriteLine(atom.index());
</code></pre>

<p>Python:</p>

<pre><code>print mol.countComponents(), 'components'

for comp in mol.iterateComponents():
  print comp.clone().smiles()
  print "component %d: %d atoms, %d bonds\n", (comp.index(), comp.countAtoms(), comp.countBonds())
  for atom in comp.iterateAtoms():
    print atom.index()

for atom in mol.iterateAtoms():
  print atom.compomentIndex()

for atom in mol.component(0).iterateAtoms():
  print atom.index()
</code></pre>

<h2 id="canonical-smiles">Canonical SMILES</h2>

<p><code>IndigoObject.canonicalSmiles</code> method computes the canonical SMILES (also known as absolute SMILES)
string for a molecule.</p>

<p>Java:</p>

<pre><code>System.out.println(mol2.canonicalSmiles());
</code></pre>

<p>C#:</p>

<pre><code>System.Console.WriteLine(mol2.canonicalSmiles());
</code></pre>

<p>Python:</p>

<pre><code>print mol2.canonicalSmiles()
</code></pre>

<h2 id="saving-molecules">Saving Molecules</h2>

<p><code>IndigoObject.smiles</code>, when applied to a molecule, returns a SMILES string.
Similarly, <code>IndigoObject.molfile</code> returns a string with a Molfile, while <code>IndigoObject.cml</code> returns a string with CML representation.
<code>IndigoObject.saveMolfile</code> and <code>IndigoObject.saveCml</code> methods save Molfile and CML to disk.</p>

<p>Java:</p>

<pre><code>System.out.println(mol1.molfile());
System.out.println(mol2.smiles());
qmol1.saveMolfile("query.mol");
</code></pre>

<p>C#:</p>

<pre><code>System.Console.WriteLine(mol1.molfile());
System.Console.WriteLine(mol2.smiles());
qmol1.saveMolfile("query.mol");
</code></pre>

<p>Python:</p>

<pre><code>print mol1.molfile()
print mol2.smiles()
qmol1.saveMolfile("query.mol")
</code></pre>

<h2 id="loading-reactions-and-query-reactions">Loading Reactions and Query Reactions</h2>

<p>Java and C#:</p>

<pre><code>IndigoObject rxn1 = indigo.loadReaction("[I-].[Na+].C=CCBr&gt;&gt;[Na+].[Br-].C=CCI");
IndigoObject rxn2 = indigo.loadReactionFromFile("reaction.rxn");
IndigoObject qrxn1 = indigo.loadQueryReaction("CBr&gt;&gt;CCl");
IndigoObject qrxn2 = indigo.loadQueryReactionFromFile("query.rxn");
IndigoObject rs    = indigo.loadReactionSmarts("[C$(CO)]&gt;&gt;[C$(CN)]");
IndigoObject rs2   = indigo.loadReactionSmartsFromFile("query.sma");
</code></pre>

<p>Python: the same with the <code>IndigoObject</code> omitted.</p>

<h2 id="instrumenting-reactions">Instrumenting Reactions</h2>

<p>The <code>Indigo.createReaction</code> method returns an empty reaction. The <code>Indigo.createQueryReaction</code> method returns an empty query reaction.
The <code>IndigoObject.addReactant</code>, <code>IndigoObject.addProduct</code>, and <code>IndigoObject.addCatalyst</code> methods can then be used to fill it up.</p>

<p>Java and C#:</p>

<pre><code>IndigoObject rxn = indigo.createReaction();
rxn.addReactant(mol1);
rxn.addReactant(mol2);
rxn.addProduct(indigo.loadMolecule("ClC1CCCCC1));
</code></pre>

<p>Python: the same with the <code>IndigoObject</code> omitted.</p>

<h2 id="accessing-reactions">Accessing Reactions</h2>

<p>Reactions respond to the following <code>IndigoObject</code> methods:</p>

<ul>
<li><code>IndigoObject.iterateReactants</code> &#8212; enumerates reactants</li>
<li><code>IndigoObject.iterateProducts</code> &#8212; enumerates products</li>
<li><code>IndigoObject.iterateCatalysts</code> &#8212; enumerates catalysts</li>
<li><code>IndigoObject.iterateMolecules</code>  &#8212; enumerates reactants, products, and catalysts, in no particular order</li>
<li><code>IndigoObject.countReactants</code> &#8212; returns the number of reactants</li>
<li><code>IndigoObject.countProducts</code> &#8212; returns the number of products</li>
<li><code>IndigoObject.countCatalysts</code> &#8212; returns the number of catalysts</li>
<li><code>IndigoObject.countMolecules</code> &#8212; returns the total number of molecules in the reaction</li>
</ul>

<p>You can also call the <code>IndigoObject.remove</code> method of the reaction molecule to remove it from the reaction.</p>

<p>Java:</p>

<pre><code>System.out.println(rxn.countMolecules());
for (IndigoObject item : rxn.iterateReactants())
   System.out.println(item.molfile());

for (IndigoObject item : rxn.iterateCatalysts())
   item.remove();
</code></pre>

<p>C#:</p>

<pre><code>System.Console.WriteLine(rxn.countMolecules());
foreach (IndigoObject item in rxn.iterateReactants())
   System.Console.WriteLine(item.molfile());

foreach (IndigoObject item in rxn.iterateCatalysts())
   item.remove();
</code></pre>

<p>Python:</p>

<pre><code>print rxn.countMolecules()
for item in rxn.iterateReactants():
   print item.molfile()

for item in rxn.iterateCatalysts():
   item.remove();
</code></pre>

<h2 id="saving-reactions">Saving Reactions</h2>

<p>The <code>IndigoObject.smiles</code>, when applied to a reaction, returns a reaction SMILES string.
Similarly, the <code>IndigoObject.rxnfile</code> returns a string with an Rxnfile.
The <code>IndigoObject.saveRxnfile</code> method saves the Rxnfile to disk.</p>

<p>Java:</p>

<pre><code>System.out.println(rxn.smiles());
System.out.println(rxn.rxnfile());
rxn.saveRxnfile("reaction.rxn");
</code></pre>

<p>C#:</p>

<pre><code>System.Console.WriteLine(rxn.smiles());
System.Console.WriteLine(rxn.rxnfile());
rxn.saveRxnfile("reaction.rxn");
</code></pre>

<p>Python:</p>

<pre><code>print rxn.smiles()
print rxn.rxnfile()
rxn.saveRxnfile("reaction.rxn")
</code></pre>

<h2 id="reacting-centers">Reacting Centers</h2>

<p>Reacting centers include bonds that are involded in the reaction. Indigo supports the following types of reacting centers:</p>

<ul>
<li><code>Indigo.RC_NOT_CENTER</code></li>
<li><code>Indigo.RC_UNMARKED</code></li>
<li><code>Indigo.RC_CENTER</code></li>
<li><code>Indigo.RC_UNCHANGED</code></li>
<li><code>Indigo.RC_MADE_OR_BROKEN</code></li>
<li><code>Indigo.RC_ORDER_CHANGED</code></li>
</ul>

<p>These values are bit flags, and can be combinded. <code>IndigoObject.reactingCenter</code> and <code>IndigoObject.setReactingCenter</code> are 
the getter and setter of the bond reacting center property.</p>

<p>Python:</p>

<pre><code>print("reacting centers:")
for m in rxn.iterateMolecules():
    for b in m.iterateBonds():
        print(rxn.reactingCenter(b))
for m in rxn.iterateMolecules():
    for b in m.iterateBonds():
        rxn.setReactingCenter(b, Indigo.RC_CENTER | Indigo.RC_UNCHANGED)
</code></pre>

<p>The <code>IndigoObject.correctReactingCenters</code> method highlights bond reacting centers according to AAM.</p>

<p>Java, C#, and Python:</p>

<pre><code>rxn.automap("discard");
rxn.correctReactingCenters();
</code></pre>

<h2 id="reaction-atomtoatom-mapping">Reaction Atom-to-Atom Mapping</h2>

<p>The <code>IndigoObject.automap(mode [ignore_option])</code> method is purposed for generating reaction atom-to-atom
mapping (AAM). The method accepts a string parameter called <code>mode</code>. The following
modes are available:</p>

<ul>
<li><code>discard</code> : discards the existing mapping entirely and considers only the existing reaction centers (the default)</li>
<li><code>keep</code>    : keeps the existing mapping and maps unmapped atoms</li>
<li><code>alter</code>   : alters the existing mapping, and maps the rest of the
reaction but may change the existing mapping</li>
<li><code>clear</code>   : removes the mapping from the reaction</li>
</ul>

<p>Java, C#, and Python:</p>

<pre><code>rxn.automap("discard");
rxn.saveRxnfile("rxn_aam.rxn");
rxn.automap("clear");
rxn.saveSmiles("rxn_noaam.smi");
</code></pre>

<p>The following options can be added after the <code>discard</code>, <code>keep</code> or <code>alter</code> modes (separated by a space):</p>

<ul>
<li><code>ignore_charges</code> : do not consider atom charges while searching</li>
<li><code>ignore_isotopes</code> : do not consider atom isotopes while searching</li>
<li><code>ignore_valence</code> : do not consider atom valence while searching </li>
<li><code>ignore_radicals</code> : do not consider atom radicals while searching</li>
</ul>

<p>Python:</p>

<pre><code>rxn.automap("alter ignore_charges")
for in rxn.iterateMolecules():
    for atom in mol.iterateAtoms():
        print("Atom %d %d" % atom.index(), atom.atomMappingNumber())
rxn.automap("alter ignore_charges ignore_valence")
...
</code></pre>

<p>The <code>IndigoObject.clearAAM</code> method resets current atom-to-atom mapping. Reaction atom 
has method <code>IndigoObject.atomMappingNumber</code> and <code>IndigoObject.setAtomMappingNumber</code> to get
and set atom-to-atom mapping manually.</p>

<p>Java, C#, and Python:</p>

<pre><code>rxn.clearAAM();
rxn.saveSmiles("rxn_noaam.smi");
</code></pre>

<p>The <code>aam-timeout</code> indigo integer parameter (time in milliseconds) corresponds for the AAM algorithm working time. The AAM method returns a current state solution for a reaction when time is over.</p>

<p>Java, C#, and Python:</p>

<pre><code>indigo.setOption("aam-timeout", 500);
rxn.automap("discard");
rxn.saveSmiles("rxn_time.smi");
</code></pre>

<h2 id="attachment-points">Attachment points</h2>

<p>Every molecule can have many attachment points. They are grouped by order - the number of connections. 
For example, a molecule can have 2 attachment points with order 1, and 3 attachment points with order 2.
The following methods of <code>IndigoObject</code> for a molecule are available for working with attachment points:</p>

<ul>
<li><code>clearAttachmentPoints</code> resets all the attachment points.</li>
<li><code>countAttachmentPoints</code> returns maximal order of attachment points.</li>
<li><code>iterateAttachmentPoints(order)</code> iterates atoms corresposing to the attachment points with the same specified order.</li>
</ul>

<p>Python:</p>

<pre><code>count = mol.countAttachmentPoints()
print("%s Number of attachment points: %s" % (offset, count))
for order in range(1, count + 1):
    for a in mol.iterateAttachmentPoints(order):
        print("%s   Index: %d. Order %d" % (offset, a.index(), order))
 mol.clearAttachmentPoints()
</code></pre>

<h2 id="layout-2d-coordinates">Layout (2D coordinates)</h2>

<p>The <code>IndigoObject.layout</code> method performs the cleanup of the object it is applied to by computing atoms 2D coordinates.</p>

<p>Java, C#, and Python:</p>

<pre><code>mol.layout();
rxn.layout();
</code></pre>

<h2 id="aromaticity">Aromaticity</h2>

<p>The <code>IndigoObject.aromatize</code> and <code>IndigoObject.dearomatize</code> methods convert molecules/reactions
to aromatic and Kekule forms respectively.</p>

<p>Java, C#, and Python:</p>

<pre><code>mol1.dearomatize();
rxn.aromatize();
</code></pre>

<h2 id="implicit-and-explicit-hydrogens">Implicit and Explicit Hydrogens</h2>

<p>Indigo does not change the representation of the hydrogens automatically. If the hydrogens in the input structure or reaction are implicit (this is usually the case), Indigo does not add the missing hydrogens to the structure or reaction. If some (or all) of hydrogens in the input are explicitly drawn, Indigo does not remove them.</p>

<p>You can force folding (i.e. removal) or unfolding (i.e. addition) the hydrogens of a molecule or reaction by calling <code>IndigoObject.foldHydrogens</code> and <code>IndigoObject.unfoldHydrogens</code> methods.</p>

<p>Java, C#, and Python:</p>

<pre><code>mol.unfoldHydrogens();
mol.foldHydrogens();
rxn.unfoldHydrogens();
rxn.foldHydrogens();
</code></pre>

<h2 id="stereochemistry">Stereochemistry</h2>

<p>The following methods of <code>IndigoObject</code> are available for accessing molecule's stereo configuration:</p>

<ul>
<li><code>countStereocenters</code> returns the number of the chiral atoms in a molecule</li>
<li><code>iterateStereocenters</code> returns an iterator for molecule's atoms that are stereocenters</li>
<li><code>countAlleneCenters</code> returns the number of allene-like stereo fragments</li>
<li><code>iterateAlleneCenters</code> returns an iterator for molecule's atoms that are centers of allene fragments (the middle 'C' in 'C=C=C')</li>
<li><code>bondStereo</code> returns one of the following constants:<ul>
<li><code>Indigo.UP</code> &#8212; stereo "up" bond</li>
<li><code>Indigo.DOWN</code> &#8212; stereo "down" bond</li>
<li><code>Indigo.EITHER</code> &#8212; stereo "either" bond</li>
<li><code>Indigo.CIS</code> &#8212; "Cis" double bond</li>
<li><code>Indigo.TRANS</code> &#8212; "Trans" double bond</li>
<li>zero &#8212; not a stereo bond of any kind</li>
</ul>
</li>
<li><code>stereocenterType</code> returns one of the following constants:<ul>
<li><code>Indigo.ABS</code> &#8212; "absolute" stereocenter</li>
<li><code>Indigo.OR</code> &#8212; "or" stereocenter</li>
<li><code>Indigo.AND</code> &#8212; "and" stereocenter</li>
<li><code>Indigo.EITHER</code> &#8212; "any" stereocenter</li>
<li>zero &#8212; not a stereocenter<br>
</li>
</ul>
</li>
<li><code>invertStereo</code> inverts the stereo configuration of an atom</li>
<li><code>resetStereo</code> resets the stereo configuration of an atom or a bond</li>
<li><code>changeStereocenterType(newType)</code> changes current stereocenter type to a specified type</li>
<li><code>addStereocenter(type, idx1, idx2, idx3, [idx4])</code> adds new stereocenter build on a atom pyramid with a specified atom indices </li>
<li><code>clearStereocenters</code> resets the chiral configurations of a molecule's atoms</li>
<li><code>clearAlleneCenters</code> resets the chiral configurations of a molecule's allene-like fragments</li>
<li><code>clearCisTrans</code> resets the cis-trans configurations of a molecule's bonds</li>
</ul>

<p>The following methods are useful for keeping cis-trans stereochemistry intact when converting to/from SMILES:</p>

<ul>
<li><code>resetSymmetricCisTrans</code> can be called on a molecule loaded from a Molfile or CML. After this call,
     the cis-trans configurations remain only on nonsymmetric cis-trans bonds. The method returns the
     number of bonds that have been reset.</li>
<li><code>markEitherCisTrans</code> can be called prior to saving a molecule loaded from SMILES to Molfile format.
     It guarantees that the bonds that have no cis-trans configuration in SMILES will not have
     a cis-trans configuration in the resulting Molfile.</li>
</ul>

<p>Java:</p>

<pre><code>  IndigoObject mol = indigo.loadMolecule("chiral.mol");

  System.output.println("%d chiral atoms\n", mol.countStereocenters());
  for (IndigoObject atom : mol.iterateStereocenters())
  {
     System.out.printf("atom %d -- stereocenter type %d\n", atom.index(), atom.stereocenterType());
     atom.invertStereo();
  }

  for (IndigoObject bond : mol.iterateBonds())
     if (bond.bondStereo() != 0)
       System.out.printf("bond %d -- stereo type %d\n", bond.index(), bond.bondStereo());

  System.out.println(mol.smiles());
  mol.clearStereocenters();
  mol.clearCisTrans();
  System.out.println(mol.smiles());
</code></pre>

<p>C#:</p>

<pre><code>  IndigoObject mol = indigo.loadMolecule("chiral.mol");

  System.Console.WriteLine("{0} chiral atoms\n", mol.countStereocenters());
  foreach (IndigoObject atom in mol.iterateStereocenters())
  {
     System.Console.WriteLine("atom {0} -- stereocenter type {1}\n", atom.index(), atom.stereocenterType());
     atom.invertStereo();
  }

  foreach (IndigoObject bond in mol.iterateBonds())
     if (bond.bondStereo() != 0)
       System.Console.WriteLine("bond {0} -- stereo type {1}\n", bond.index(), bond.bondStereo());

  System.Console.WriteLine(mol.smiles());
  mol.clearStereocenters();
  mol.clearCisTrans();
  System.out.println(mol.smiles());
</code></pre>

<p>Python:</p>

<pre><code>  IndigoObject mol = indigo.loadMolecule("chiral.mol");

  print mol.countStereocenters(), "chiral atoms"
  for atom in mol.iterateStereocenters():
     print "atom", atom.index(), "-- stereocenter type", atom.stereocenterType()
     atom.invertStereo();

  for bond in mol.iterateBonds():
     if bond.bondStereo() != 0:
       print "bond", bond.index(), "-- stereo type", bond.bondStereo()

  print mol.smiles()
  mol.clearStereocenters()
  mol.clearCisTrans()
  print mol.smiles()
</code></pre>

<h2 id="groups">Groups</h2>

<p>In a molecule loaded from a Molfile, arbitrary subsets of a its atoms and bonds can be joined in groups.
There are many kinds of groups, Indigo supports five of them:</p>

<ul>
<li>generic groups (GEN)</li>
<li>superatoms (SUP)</li>
<li>structure repeating units (SRU)</li>
<li>multiple groups (MUL)</li>
<li>data SGroups (DAT) </li>
</ul>

<p>The following methods of <code>IndigoObject</code> are available for reading molecule's groups:</p>

<ul>
<li><code>countGenericSGroups</code></li>
<li><code>countSuperatoms</code></li>
<li><code>countRepeatingUnits</code></li>
<li><code>countMultipleGroups</code></li>
<li><code>countDataSGroups</code></li>
<li><code>iterateGenericSGroups</code></li>
<li><code>iterateSuperatoms</code></li>
<li><code>iterateRepeatingUnits</code></li>
<li><code>iterateMultipleGroups</code></li>
<li><code>iterateDataSGroups</code></li>
<li><code>getSuperatom(index)</code></li>
<li><code>getDataSGroup(index)</code></li>
</ul>

<p>The iterator methods return "group" objects. Each "group" object responds to <code>IndigoObject.iterateAtoms</code> and
<code>IndigoObject.iterateBonds</code> methods.</p>

<p>Java:</p>

<pre><code>for (IndigoObject dsg : mol.iterateDataSGroups())
{
   System.out.println("data sgroup " + dsg.index());
   for (IndigoObject atom : dsg.iterateAtoms())
      System.out.println("  atom " + atom.index());  
}
</code></pre>

<p>C#:</p>

<pre><code>foreach (IndigoObject dsg in mol.iterateDataSGroups())
{
   System.Console.WriteLine("data sgroup " + dsg.index());
   foreach (IndigoObject atom in dsg.iterateAtoms())
      System.Console.WriteLine("  atom " + atom.index());
}
</code></pre>

<p>Python:</p>

<pre><code>for dsg in mol.iterateDataSGroups():
   print "data sgroup", dsg.index()
   for atom in dsg.iterateAtoms():
      print atom.index()
</code></pre>

<p>You can also add data SGroups to an existing structure using <code>IndigoObject.addDataSGroup()</code> method. 
It returns the added group. By default, the data SGroup is added in "attached" mode &#8212; that is, the data is 
attached to each of the group's atoms. To make the data SGroup detached, you can call 
the <code>IndigoObject.setDataSGroupXY</code> method of the data SGroup object. To get a description of a data 
SGroup use method <code>IndigoObject.description()</code>.</p>

<p>To add a superatom use <code>IndigoObject.addSuperatom()</code> method:</p>

<pre><code>mol.addSuperatom(list_with_atom_indices, "Abbreviation")
</code></pre>

<h2 id="reading-sdf-rdf-cml-multiline-smiles-files">Reading SDF, RDF, CML, multiline SMILES files</h2>

<p>The following methods of the <code>Indigo</code> class can be used to enumerate files with multiple molecules/reactions:</p>

<ul>
<li><code>iterateSDFile</code></li>
<li><code>iterateRDFile</code></li>
<li><code>iterateSmilesFile</code></li>
<li><code>iterateCMLFile</code></li>
</ul>

<p>Java:</p>

<pre><code>for (IndigoObject item : indigo.iterateSDFile("structures.sdf"))
   System.out.println(item.grossFormula());
</code></pre>

<p>C#:</p>

<pre><code>foreach (IndigoObject item in indigo.iterateSDFile("structures.sdf"))
   System.Console.WriteLine(item.grossFormula());
</code></pre>

<p>Python:</p>

<pre><code>for item in indigo.iterateSDFile("structures.sdf"):
   print item.grossFormula()
</code></pre>

<h3 id="indexed-access">Indexed access</h3>

<p>You can access items from SDF/RDF/CML/SMILES files by index, using the <code>at</code> method. The numbering of the items is zero-based.</p>

<p>Java, C#:</p>

<pre><code>IndigoObject reader = indigo.iterateSDFile("structures.sdf");
String s = reader.at(15).smiles()
</code></pre>

<p>Python: the same with the <code>IndigoObject</code> and <code>String</code> omitted.</p>

<h2 id="accessing-molecule-and-reaction-properties">Accessing Molecule and Reaction Properties</h2>

<h3 id="names">Names</h3>

<p>Molecule or reaction name is associated with the first line of the Molfile/Rxnfile the molecule/reaction was loaded from. In case it was loaded from SMILES string, the word immediately following the SMILES code is taken.</p>

<p><code>IndigoObject.name</code> and <code>IndigoObject.setName</code> are the getter and setter of the molecule/reaction name.</p>

<p>Java, C#:</p>

<pre><code>String name = mol2.name();
mol2.setName("another name");
mol2.saveMolfile("mol2.mol");
</code></pre>

<p>Python: the same with the <code>IndigoObject</code> and <code>String</code> omitted.</p>

<h3 id="sdfrdf-properties">SDF/RDF Properties</h3>

<p>The following methods are used to get the named properties of the molecule/reaction
loaded from an SDF or RDF file:</p>

<ul>
<li><code>IndigoObject.hasProperty</code> (boolean) &#8212;  checks if the object has the given property.</li>
<li><code>IndigoObject.getProperty</code> (string) &#8212; returns the value of the given property, or raises an error in case the object does not have it.</li>
<li><code>IndigoObject.removeProperty</code> &#8212; removes the given property from the object, or does nothing in case the object does not have it.</li>
</ul>

<p>Java:</p>

<pre><code>for (IndigoObject item : indigo.iterateSDFile("structures.sdf"))
   if (item.hasProperty("cdbregno"))
      System.out.println(item.getProperty("cdbregno"));
</code></pre>

<p>C#:</p>

<pre><code>foreach (IndigoObject item in indigo.iterateSDFile("structures.sdf"))
   if (item.hasProperty("cdbregno"))
      System.Console.WriteLine(item.getProperty("cdbregno"));
</code></pre>

<p>Python:</p>

<pre><code>for item in indigo.iterateSDFile("structures.sdf"):
   if item.hasProperty("cdbregno"):
      print item.getProperty("cdbregno")
</code></pre>

<p>It is also possible to iterate over all properties of a particular
record in SDF or RDF file.</p>

<p>Java:</p>

<pre><code>for (IndigoObject item : indigo.iterateRDfile("reactions.rdf"))
   for (IndigoObject prop : item.iterateProperties())
      System.out.println(prop.name() + " : " + prop.rawData())
</code></pre>

<p>C#:</p>

<pre><code>foreach (IndigoObject item in indigo.iterateRDfile("reactions.rdf"))
   foreach (IndigoObject prop in item.iterateProperties())
      System.Console.WriteLine(prop.name() + " : " + prop.rawData())
</code></pre>

<p>Python:</p>

<pre><code>for item in indigo.iterateRDFile("reactions.rdf"):
   for prop in item.iterateProperties():
      print prop.name(), ":", prop.rawData()
</code></pre>

<h2 id="writing-multiple-molecules-or-reactions-to-a-file">Writing Multiple Molecules or Reactions to a File</h2>

<h3 id="writing-sdf-files">Writing SDF Files</h3>

<p>It is possible to write molecules to SDF files, along with arbitrary properties assigned.</p>

<p>Java and C#:</p>

<pre><code>IndigoObject saver = indigo.writeFile("structures.sdf");

IndigoObject mol = indigo.loadMolecule("C1CCC1");
mol.setName("cyclobutane");
mol.setProperty("id", "8506");
saver.sdfAppend(mol);

mol = indigo.loadMolecule("C(NNN)C");
mol.setProperty("id", "42");
saver.sdfAppend(mol);
</code></pre>

<p>Python: the same with the <code>IndigoObject</code> omitted.</p>

<h3 id="writing-rdf-files">Writing RDF Files</h3>

<p>Molecules and reactions can be written to an RDF file with the <code>rdfAppend</code> method. However, the special <code>rdfHeader</code> method must be called exactly once before anything is written into the RDF file.</p>

<p>Java and C#:</p>

<pre><code>IndigoObject f = indigo.writeFile("test.rdf");
f.rdfHeader();
mol.setProperty("WHAT", "a molecule");
rxn.setProperty("WHAT", "a reaction");
f.rdfAppend(mol);
f.rdfAppend(rxn);
</code></pre>

<p>Python: the same with the <code>IndigoObject</code> omitted.</p>

<h3 id="writing-cml-files">Writing CML Files</h3>

<p>Molecules can be written to a CML file with the <code>cmlAppend</code> method. However, the <code>cmlHeader</code> method must be called exactly once before anything is written into the CML file, and the <code>cmlFooter</code> method must be called after all the molecules has been written.</p>

<p>Java and C#:</p>

<pre><code>IndigoObject f = indigo.writeFile("structures.cml");
f.cmlHeader();
f.cmlAppend(mol1);
f.cmlAppend(mol2);
f.cmlFooter();
</code></pre>

<p>Python: the same with the <code>IndigoObject</code> omitted.</p>

<h3 id="writing-multiline-smiles-files">Writing Multiline SMILES Files</h3>

<p>Java and C#:</p>

<pre><code>IndigoObject f = indigo.writeFile("test.smi");
f.smilesAppend(mol);
f.smilesAppend(rxn);
</code></pre>

<p>Python: the same with the <code>IndigoObject</code> omitted.</p>

<h3 id="closing-files">Closing Files</h3>

<p>The file output stream is closed on the object's destructor. However, you may need to close it explicitly. You can use the <code>close</code> method:</p>

<pre><code>f.close();
</code></pre>

<p>You may need to be sure that the file will be closed after some block of code has finished executing.
In Java, you can call the <code>close</code> method in <code>finally</code> block:</p>

<pre><code>IndigoObject f = null;
try
{
  f = indigo.writeFile("test.sdf");
  f.sdfAppend(mol);
}
finally
{
  if (f != null)
    f.close();
}
</code></pre>

<p>In C#, the "using" statement can make the job easier:</p>

<pre><code>using (IndigoObject f = indigo.writeFile("test.sdf"))
{
  f.sdfAppend(mol);  
}
</code></pre>

<p>In Python, the "with" syntax serves the same purpose:</p>

<pre><code>with indigo.writeFile("test.sdf") as f:
  f.sdfAppend(mol)
</code></pre>

<h3 id="generic-interface-to-writing-files">Generic Interface to Writing Files</h3>

<p>There is also a generic interface to writing multiple molecules/reactions in a file. You can create a generic file saver (<code>IndigoObject.createFileSaver</code>), specifying the desired format to it, and then append items to it (<code>IndigoObject.append</code>), not bothering about header and footer &#8212; the saver will write them for you automatically.</p>

<p>The <code>IndigoObject.createFileSaver</code> method accepts the output file name and a string with the desired format, which is "sdf", "rdf", "cml", or "smi".</p>

<p>Java:</p>

<pre><code>IndigoObject saver = null;
try
{
  saver = indigo.createFileSaver("reactions.cml", "cml");
  saver.append(rxn1);
  saver.append(rxn2);
}
finally
{
  if (saver != null)
    saver.close();
}
</code></pre>

<p>C#: </p>

<pre><code>using (IndigoObject saver = indigo.createFileSaver("reactions.cml", "cml"))
{
   saver.append(rxn1);
   saver.append(rxn2);
}
</code></pre>

<p>Python:</p>

<pre><code>with indigo.createFileSaver("reactions.cml", "cml") as saver:
   saver.append(rxn1);
   saver.append(rxn2);
</code></pre>

<h3 id="writing-into-a-memory-buffer">Writing into a Memory Buffer</h3>

<p>You can write the SDF or RDF data into a memory buffer instead of a file. <code>Indigo.writeBuffer</code> method creates and returns a memory output stream. After you have finished writing, you can call the <code>toString</code> method to obtain the written data.</p>

<p>Java, C#:</p>

<pre><code>IndigoObject buf = indigo.writeBuffer();
mol.setProperty("name", "cyclobutane");
buf.sdfAppend(mol);
String s = buf.toString();
</code></pre>

<p>Python: the same with the <code>IndigoObject</code> and <code>String</code> omitted.</p>

<p>You can also create a generic saver on top of an existing buffer writer</p>

<p>Java, C#:</p>

<pre><code>IndigoObject saver = indigo.createSaver(buf, "cml");
</code></pre>

<p>Python: the same with the <code>IndigoObject</code> omitted.</p>

<h2 id="enumeration-of-submolecules">Enumeration of Submolecules</h2>

<p>Indigo provides methods to enumerate submolecules of different kinds, namely:</p>

<ul>
<li>Smallest Set of Smallest Rings (SSSR) &#8212; <code>iterateSSSR</code>.</li>
<li>All rings of size within a given interval &#8212; <code>iterateRings</code>. The method accepts the minimum and maximum amounts of the rings' atoms.</li>
<li>All subtrees of size within a given interval &#8212; <code>iterateSubtrees</code>. The method accepts the minimum and maximum amounts of the subtrees' atoms.</li>
<li>All edge submolecules of size within a given interval &#8212; <code>iterateEdgeSubmolecules</code>. The method accepts the minimum and maximum amounts of the submolecules' edges.</li>
</ul>

<p>The "submolecule" objects returned by these methods respond to the <code>countAtoms</code>, <code>countBonds</code>, <code>iterateAtoms</code>, and <code>iterateBonds</code> calls. However, they can not be used as molecules. If you want to have a separate molecule representing the obtained submolecule, you should <code>clone</code> it.</p>

<p>Java:</p>

<pre><code>for (IndigoObject submol : mol.iterateEdgeSubmolecules(1, mol.countBonds())
{
  System.out.printf("submolecule #%d: %s\n", submol.index(), submol.clone().smiles());
  for (IndigoObject atom : item.iterateAtoms())
    System.out.printf("%d ", atom.index());
  System.out.printf("\n");
  for (IndigoObject bond : item.iterateBonds())
    System.out.printf("%d ", bond.index());
  System.out.printf("\n");
}
</code></pre>

<p>C#: </p>

<pre><code>foreach (IndigoObject item in mol.iterateEdgeSubmolecules(1, mol.countAtoms()))
{
  System.Console.WriteLine("{0} {1}", item.index(), item.clone().smiles());
  foreach (IndigoObject atom in item.iterateAtoms())
    System.Console.Write("{0} ", atom.index());
  System.Console.WriteLine();
  foreach (IndigoObject bond in item.iterateBonds())
    System.Console.Write("{0} ", bond.index());
  System.Console.WriteLine();
}
</code></pre>

<p>Python:</p>

<pre><code>for submol in mol.iterateEdgeSubmolecules(1, mol.countBonds()):
  print "submolecule", submol.index(), ":", submol.clone().smiles())
  print [atom.index() for atom in item.iterateAtoms()]
  print [bond.index() for bond in item.iterateBonds()]
</code></pre>

<h2 id="fingerprints">Fingerprints</h2>

<p>The <code>IndigoObject.fingerprint</code> method works for molecules and reactions
(including query molecules and query reactions) and returns a <code>fingerprint</code>
object. <code>IndigoObject.toString</code> and <code>IndigoObject.toBuffer</code> methods
of that object can be called to obtain a hex-string representation or
a byte array of a fingerprint, respectively.</p>

<p>The <code>fingerprint</code> method accepts a string with a requested fingerprint
type. The following fingerprint types are available:</p>

<ul>
<li><code>sim</code> &#8212; "Similarity fingerprint", useful for calculating similarity measures (the default)</li>
<li><code>sub</code> &#8212; "Substructure fingerprint", useful for substructure screening </li>
<li><code>sub-res</code> &#8212; "Resonance substructure fingerprint", useful for resonance
                  substructure screening</li>
<li><code>sub-tau</code> &#8212; "Tautomer substructure fingerprint", useful for tautomer
                  substructure screening</li>
<li><code>full</code> &#8212; "Full fingerprint", which has all the mentioned fingerprint types included</li>
</ul>

<p>The size of the fingerprint can be controlled via a number of
<a href="options.html#fingerprinting">fingerprinting options</a>.</p>

<p>Java:</p>

<pre><code>fp1 = mol1.fingerprint("sim");
fp2 = mol2.fingerprint("sim");
String fp1string = fp1.toString();
byte[] fp2bytes = fp1.toBuffer();
</code></pre>

<p>Python: the same with <code>IndigoObject</code> and <code>String</code> omitted.</p>

<p>The <code>IndigoObject.countBits</code> method calculates the number of nonzero bits in a fingerprint.
The <code>Indigo.commonBits</code> method calculates the number of coincident nonzero bits
in two fingerprints.</p>

<p>Java and C#:</p>

<pre><code>int bits1 = fp1.countBits();
int bits2 = fp2.countBits();
int bits12 = indigo.commonBits(fp1, fp2);
</code></pre>

<p>Python: the same with the <code>int</code> omitted.</p>

<h2 id="molecule-and-reaction-similarity">Molecule and Reaction Similarity</h2>

<p>The <code>Indigo.similarity</code> method accepts two molecules, two reactions, or two fingerprints.
It also accepts a "metrics" string and returns a float value &#8212; the similarity
measure between the two given items. There are three available metrics,
which are calculated in the following way:</p>

<ul>
<li><code>tanimoto</code> (the default) : c / (a + b - c)</li>
<li><code>tversky &lt;alpha&gt; &lt;beta&gt;</code>: c / ((a - c) * alpha + (b - c) * beta) (if alpha and beta are omitted, they are taken for alpha = beta = 0.5)</li>
<li><code>euclid-sub</code>: c / a</li>
</ul>

<p>Where:</p>

<ul>
<li>"a" is the number of nonzero bits in the first fingerprint</li>
<li>"b" is the number of nonzero bits in the second fingerprint</li>
<li>"c" is the number of coincident bits in the two fingerprints</li>
</ul>

<p>Java and C#:</p>

<pre><code>float sim1 = indigo.similarity(fp1, fp2, "tanimoto");
float sim2 = indigo.similarity(rxn1, rxn2, "tversky");
float sim2 = indigo.similarity(mol1, mol2, "tversky 0.1 0.9");
float sim4 = indigo.similarity(mol1, mol2, "euclid-sub");
</code></pre>

<p>Python: the same with the <code>float</code> omitted.</p>

<h2 id="exact-match">Exact Match</h2>

<p>The <code>Indigo.exactMatch</code> method accepts two molecules or reactions and returns a "mapping" object &#8212; the result of the exact match of two given molecules or reactions. If match is not possible, it returns <code>null</code>. If you are interested only in does the match exist or not, you can just check if the result of the method is <code>null</code>. Otherwise, please check <a href="index.html#methods-of-mapping-object">below</a> how to work with the mapping objects.</p>

<p><strong>Note:</strong> You can not pass query molecules or reactions to <code>exactMatch</code>.</p>

<h3 id="exact-matching-flags-for-molecules">Exact Matching Flags for Molecules</h3>

<p>The <code>Indigo.exactMatch</code> method accepts an optional string. In this string, you can pass the following flags to the matching procedure:</p>

<table>
<thead>
<tr>
<th>Flag</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>ELE</code></td>
<td align="left">Distribution of electrons: bond types, atom charges, radicals, valences</td>
</tr>
<tr>
<td align="center"><code>MAS</code></td>
<td align="left">Atom isotopes</td>
</tr>
<tr>
<td align="center"><code>STE</code></td>
<td align="left">Stereochemistry: chiral centers, stereogroups, and cis-trans bonds</td>
</tr>
<tr>
<td align="center"><code>FRA</code></td>
<td align="left">Connected fragments: disallows match of separate ions in salts</td>
</tr>
<tr>
<td align="center"><code>ALL</code></td>
<td align="left">All of the above (the most permissive matching)</td>
</tr>
<tr>
<td align="center"><code>TAU</code></td>
<td align="left">Tautomer matching (not compatible to other flags)</td>
</tr>
<tr>
<td align="center"><code>NONE</code></td>
<td align="left">No conditions (the most flexible kind of search)</td>
</tr>
<tr>
<td align="center"><code>$number</code></td>
<td align="left">Maximum allowed RMS value for affine transformation match</td>
</tr>
</tbody>
</table>

<p>The flags should go in the parameters string separated by space. Each flag specifies a constraint for the matching procefure. The more flags you set, the more restrictive the matching is. You can write the minus sign before
the flag to exclude it from the 'ALL' flag. For example, 'ALL -MAS' means that all the described features except
the isotopes must match.</p>

<p>The <code>TAU</code> flag stands for tautomer matching. It can not be combined with any other flags.
You can see examples of exact matching, <a href="../../bingo/user-manual-oracle.html#affine-transformation-search">affine transformation matching</a>, and <a href="../../bingo/user-manual-oracle.html#exact-tautomer-search">exact tautomer matching</a> in the Bingo User Manual.</p>

<p><strong>Note</strong>: When no flags are specified, the behavior is equivalent to the <code>ALL</code> flag.</p>

<p>The <code>$number</code>, if present, should go after the flags; for example: <code>ALL 0.1</code>. The given <code>number</code> is the maximum allowed root-mean-square deviation between the atoms of the two molecules, measured in angstroms. Prior to the calculation of the RMS value, the optimal affine transformation (translation+rotation+scale) is applied to one of the molecules to make it as close as possible to the other molecule.</p>

<p><strong>Note</strong>: Affine transformation matching is not possible when the molecule's atoms do not have coordinates (e.g. the molecule was loaded from SMILES).</p>

<p>Java and C#:</p>

<pre><code>IndigoObject match = indigo.exactMatch(mol1, mol2, "ALL 0.1");

if (match == null) // affine matching has failed?
   match = indigo.exactMatch(mol1, mol2);

if (match == null) // exact match has failed, trying to ignore stereochemistry
   match = indigo.exactMatch(mol1, mol2, "ALL -STE");

if (match == null) // failed again; trying the most permissive matching
   match = indigo.exactMatch(mol1, mol2, "NONE");
</code></pre>

<p>Python:</p>

<pre><code>match = indigo.exactMatch(mol1, mol2, "ALL 0.1")
if not match:
   match = indigo.exactMatch(mol1, mol2) # eqiuvalent to ALL
if not match:
   match = indigo.exactMatch(mol1, mol2, "ALL -STE") # equivalent to "ELE MAS FRA"  
if not match:
   match = indigo.exactMatch(mol1, mol2, "NONE")
</code></pre>

<h3 id="exact-matching-flags-for-reactions">Exact Matching Flags for Reactions</h3>

<p>When calling the <code>Indigo.exactMatch</code> method for reactions, you can pass it the "ELE", "MAS", and "STE" flags, which have the same meaning as in molecule exact matching. You can also pass two reaction-specific flags:</p>

<table>
<thead>
<tr>
<th>Flag</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>AAM</code></td>
<td align="left">Atom-atom mapping</td>
</tr>
<tr>
<td align="center"><code>RCT</code></td>
<td align="left">Reacting centers</td>
</tr>
</tbody>
</table>

<p><strong>Note:</strong> <code>FRA</code>, <code>TAU</code>, and affine matching are not available for reactions.</p>

<h2 id="molecule-substructure-matching">Molecule Substructure Matching</h2>

<p>The <code>Indigo.substructureMatcher</code> method accepts a molecule (but not a query molecule) and returns a "substructure matcher" object. The given molecule is going to be the "target" molecule for the substructure match.</p>

<h3 id="molecule-substructure-matching-flags">Molecule Substructure Matching Flags</h3>

<p>The <code>Indigo.substructureMatcher</code> method accepts an optional string, in which you can specify one of the following flags:</p>

<ul>
<li>
<p><code>RES</code> &#8212; to turn on the chemical resonance matching mode (<code>C=N</code> matches <code>CN=O</code> etc). You can read more about the resonance search and see examples on the <a href="../../bingo/user-manual-oracle.html#resonance-search">Bingo User Manual</a> page.</p>
</li>
<li>
<p><code>TAU</code> &#8212; to turn on the tautomer matching mode.  You can read more about the tautomer substructure search and see examples on the <a href="../../bingo/user-manual-oracle.html#tautomer-substructure-search">Bingo User Manual</a> page.</p>
</li>
</ul>

<h3 id="methods-of-substructure-matcher">Methods of Substructure Matcher</h3>

<ul>
<li><code>IndigoObject.ignoreAtom</code> method accepts an atom of the target molecule and marks it as "ignored" for the substructure matcher. No atom of any query will be mapped to this atom.</li>
<li><code>IndigoObject.unignoreAtom</code> method cancels the effect of the <code>ignoreAtom</code> method for the given atom.</li>
<li><code>IndigoObject.unignoreAllAtoms</code> method cancels the effect of previous <code>ignoreAtom</code> calls.</li>
<li><code>IndigoObject.match</code> accepts a query molecule and returns a "mapping" object if the matching has succeeded. If multiple matches are possible, the first one is taken. If no match is possible, it returns <code>null</code>.</li>
<li><code>IndigoObject.countMatches</code> accepts a query molecule and returns the number or unique matches.</li>
<li><code>IndigoObject.countMatchesWithLimit</code> works like <code>countMatches</code>, but also accepts an additional integer parameter for limiting the number of matches.</li>
<li><code>IndigoObject.iterateMatches</code> accepts a query molecule and returns an iterator for unique matches ("mapping" objects).</li>
</ul>

<p>Also, please take a look on some <a href="options.html#substructure-matching">options</a> available for substructure matchers.</p>

<h2 id="reaction-substructure-matching">Reaction Substructure Matching</h2>

<p>You can pass a reaction to the <code>Indigo.substructureMatcher</code> method to obtain a "reaction substructure matcher" object. It responds to the <code>IndigoObject.match</code> method similarly to the molecule matcher. This method returns a "reaction match" object, or <code>null</code> if the matching is not possible.</p>

<p>You can specify optional <code>DAYLIGHT-AAM</code> flag to the matcher. When this flag is present, the matching of the atom-atom mapping (reaction AAM) is following the Daylight's rules for <a href="http://www.daylight.com/dayhtml/doc/theory/theory.smarts.html">reaction SMARTS</a>. Otherwise, it follows ordinary rules that are normal for matching Rxnfiles.</p>

<p>Java and C#:</p>

<pre><code>IndigoObject rxn1 = indigo.loadReactionSmarts("[C:1][C:1]&gt;&gt;[C:1]");
IndigoObject rxn2 = indigo.loadReaction("[CH3:7][CH3:8]&gt;&gt;[CH3:7][CH3:8]");
IndigoObject match = indigo.substructureMatcher(rxn2, "DAYLIGHT-AAM").match(rxn1);
</code></pre>

<p>Python: the same with the <code>IndigoObject</code> omitted.</p>

<p><strong>Note:</strong> <code>ignoreAtom</code>, <code>unignoreAtoms</code>, <code>unignoreAllAtoms</code>, <code>countMatches</code>, <code>countMatchesWithLimit</code>, and <code>iterateMatches</code> methods are not supported by reaction substructure matcher.</p>

<h2 id="converting-the-substructure-query-to-the-aromatic-form">Converting the Substructure Query to the Aromatic Form</h2>

<p>If your query is loaded from a Molfile or SMILES and its aromatic rings are represented in Kekule form, you should transform it to aromatic form prior to matching. Otherwise, it will not match the aromatic rings in the target structure.</p>

<p>Java and C#:</p>

<pre><code>IndigoObject query = indigo.loadMoleculeFromFile("kekule.mol");
query.aromatize();
</code></pre>

<p>Python: the same with the <code>IndigoObject</code> omitted.</p>

<p><strong>Note:</strong> <code>aromatize</code> does not have any effect for SMARTS queries (and should not be called on them).</p>

<h2 id="optimizing-the-substructure-query">Optimizing the Substructure Query</h2>

<p>If you have a complex molecule or reaction SMARTS query, you can "optimize" it in-memory so that the matching performs faster.</p>

<p>Java and C#:</p>

<pre><code>IndigoObject query = indigo.loadSmarts("[$([a;r4,!R1&amp;r3])]1:[$([a;r4,!R1&amp;r3])]:[$([a;r4,!R1&amp;r3])]:[$([a;r4,!R1&amp;r3])]:1");
query.optimize();
</code></pre>

<p>Python: the same with the <code>IndigoObject</code> omitted.</p>

<h2 id="methods-of-mapping-object">Methods of "mapping" object</h2>

<p>You can get the detailed information about the succeeded matching via the returned "mapping" <code>IndigoObject</code>. It responds to the following method calls:</p>

<ul>
<li><code>IndigoObject.mapAtom</code> method accepts an atom of the query molecule/reaction and returns the corresponding atom from the target molecule/reaction. In case the query atom is unmapped (this can happen only with explicit hydrogens), it returns <code>null</code>. You can use <code>IndigoObject.index</code> method to get mapped atom intex.</li>
<li><code>IndigoObject.mapBond</code> method is similar to <code>mapAtom</code>, but accepts a bond of the query and returns a bond of the target. It can also return <code>null</code> if the bond is unmapped (this can happen only with bonds to explicit hydrogens).</li>
<li><code>IndigoObject.mapMolecule</code> method is similar to <code>mapAtom</code>, but accepts a molecule of the query reaction and returns a molecule of the target reaction. It can also return <code>null</code> if the molecule is unmapped (this can happen if a molecule within a query reaction represents explicit hydrogen).</li>
<li><code>IndigoObject.highlightedTarget</code> method returns a copy of the target molecule/reaction where the matched atoms and bonds are highlighted.</li>
</ul>

<p><strong>Note:</strong> The <code>IndigoObject.mapAtom</code> and <code>IndigoObject.ignoreAtom</code> methods accepts only atoms, and not atom indices. Similarly, the <code>IndigoObject.mapBond</code> and <code>IndigoObject.mapMolecule</code> method accepts only bonds and molecules respectively, and not their indices.</p>

<h3 id="example-1-mapping-query-molecule-atoms">Example 1 (mapping query molecule atoms)</h3>

<p>Java:</p>

<pre><code>IndigoObject match = indigo.substructureMatcher(mol).match(query);

if (match != null)
{
   match.highlightedTarget().saveMolfile("highlighted.mol");
   for (IndigoObject atom : qmol2.iterateAtoms())
      System.out.printf("atom %d mapped to atom %d\n", atom.index(), match.mapAtom(atom).index());
}
</code></pre>

<p>C#:</p>

<pre><code>IndigoObject match = indigo.substructureMatcher(mol).match(query);

if (match != null)
{
   match.highlightedTarget().saveMolfile("highlighted.mol");
   foreach (IndigoObject atom in qmol2.iterateAtoms())
      System.Console.WriteLine("atom {0} mapped to atom {1}", atom.index(), match.mapAtom(atom).index());
}
</code></pre>

<p>Python:</p>

<pre><code>match = indigo.substructureMatcher(mol).match(query)

if match:
   match.highlightedTarget().saveMolfile("highlighted.mol")
   for atom in qmol2.iterateAtoms():
      print "atom", atom.index(), "mapped to atom", match.mapAtom(atom).index())
</code></pre>

<h3 id="example-2-getting-the-highlighted-target-molecule">Example 2 (getting the highlighted target molecule)</h3>

<p>Java:</p>

<pre><code>IndigoObject matcher = indigo.substructureMatcher(mol);
IndigoObject query = indigo.loadSmarts("O=[!C;R]");

System.out.println(matcher.countMatches(query);
for (IndigoObject match : matcher.iterateMatches(query))
   System.out.println(match.highlightedTarget().smiles());
</code></pre>

<p>C#:</p>

<pre><code>IndigoObject matcher = indigo.substructureMatcher(mol);
IndigoObject query = indigo.loadSmarts("O=[!C;R]");

System.Console.WriteLine(matcher.countMatches(query);
foreach (IndigoObject match in matcher.iterateMatches(query))
   System.Console.WriteLine(match.highlightedTarget().smiles());
</code></pre>

<p>Python:</p>

<pre><code>matcher = indigo.substructureMatcher(mol)
query = indigo.loadSmarts("O=[!C;R]")

print matcher.countMatches(query)
for match in matcher.iterateMatches(query):
   print match.highlightedTarget().smiles()
</code></pre>

<h3 id="example-3-exact-match-between-reactions">Example 3 (exact match between reactions)</h3>

<p>Java:</p>

<pre><code>IndigoObject match = indigo.exactMatch(rxn1, rxn2, "ALL -AAM");

if (match != null)
{
   for (IndigoObject mol : rxn1.iterateMolecules())
   {
      System.out.println("molecule #" + mol.index());

      for (IndigoObject atom : mol.iterateAtoms())
        if (match.mapAtom(atom) != null)
           System.out.printf("atom #%d matched\n", atom.index());

      for (IndigoObject bond : mol.iterateBonds())
        if (match.mapBond(atom) != null)
           System.out.printf("bond #%d matched\n", bond.index());
   }
}
</code></pre>

<p>C#:</p>

<pre><code>IndigoObject match = indigo.exactMatch(rxn1, rxn2, "ALL -AAM");

if (match != null)
{
   foreach (IndigoObject mol in rxn1.iterateMolecules())
   {
      System.Console.writeLine("molecule #" + mol.index());

      foreach (IndigoObject atom in mol.iterateAtoms())
        if (match.mapAtom(atom) != null)
           System.Console.WriteLine("atom #{0} matched\n", atom.index());

      foreach (IndigoObject bond in mol.iterateBonds())
        if (match.mapBond(bond) != null)
           System.Console.WriteLine("bond #{0} matched\n", bond.index());

   }
}
</code></pre>

<p>Python:</p>

<pre><code>match = indigo.exactMatch(rxn1, rxn2, "ALL -AAM")

if match:
  foreach mol in rxn1.iterateMolecules():
    print "molecule #" + mol.index();
    for atom in mol.iterateAtoms():
      if match.mapAtom(atom):
        print "atom #", atom.index(), "matched"

    for bond in mol.iterateBonds():
      if match.mapBond(bond):
        print "bond #", bond.index(), "matched"
</code></pre>

<h2 id="tautomer-matching-rules">Tautomer Matching Rules</h2>

<ul>
<li>By default, any chains that satisfy basic conditions of tautomerism, are considered tautomeric by he tautomer matcher. You can restrict the tautomer matching by enabling conditions for boundary atoms in tautomeric chains. Each rule consists of two conditions, for two boundary atoms of the chain. The rules are numbered (1,2,...), and the numbers can be used in matcher's parameter string after the <code>TAU</code> specifier (<code>TAU R1 R2</code>). The more rules you specify, the more flexibility you receive in the search; <em>but</em> when you specify no rules at all (<code>TAU</code>), you get the most flexible search because no rules are checked. Any tautomeric chain is acceptable in this case. You can also use <code>TAU R*</code> to specify all rules at once.</li>
<li>Some metal bonds and atom charges can replace hydrogen in tautomeric chains. You can add the HYD word to disable such hydrogen replacements (<code>TAU HYD</code>).</li>
<li>Ring-chain tautomerism is disabled by default. You can add <code>R-C</code> to enable it (<code>TAU R-C</code>).</li>
</ul>

<p>The following three rules are recommended and are used in examples:</p>

<ul>
<li>Each boundary atom in the tautomeric chain must be one of N, O, P, S, As, Se, Sb, Te</li>
<li>Carbon not from the aromatic ring at one end of the tautomeric chain, and one of N, O, P, S at the other end</li>
<li>Carbon from the aromatic ring at one end of the tautomeric chain and one of N, O at the other end</li>
</ul>

<h3 id="customizing-the-rules">Customizing the rules</h3>

<p><code>Indigo</code> provides thee methods to customize the rules: <code>clearTautomerRules</code>, <code>setTautomerRule</code>, and <code>removeTautomerRule</code>.
There are no rules by default. The <code>Indigo.setTautomerRule</code> method accepts an ID number of the rule (must be from 1 to 32), and two strings (for two bound atoms of the chain), containing allowed elements are separated by commas. '1' at the beginning means an aromatic atom, and '0' means an aliphatic (non-aromatic) atom.</p>

<p>The three rules defined above can be set in the following way:</p>

<p>Java and C#:</p>

<pre><code>  indigo.setTautomerRule(1, "N,O,P,S,As,Se,Sb,Te", "N,O,P,S,As,Se,Sb,Te");
  indigo.setTautomerRule(2, "0C", "N,O,P,S");
  indigo.setTautomerRule(3, "1C", "N,O");

  IndigoObject mol1 = indigo.loadQueryMolecule("OC1=CC=CNC1");
  IndigoObject mol2 = indigo.loadMolecule("O=C1CNCC2=CC=CC=C12");

  IndigoObject matcher = indigo.substructureMatcher(mol2, "TAU R2");
  IndigoObject match = matcher.match(mol1);
</code></pre>

<p>Python: the same with <code>IndigoObject</code> omitted</p>

<h2 id="highlighting-atoms-and-bonds">Highlighting Atoms and Bonds</h2>

<p>The <code>IndigoObject.highlight</code> and <code>IndigoObject.unhighlight</code> methods can be applied to an atom or a bond. Also, the <code>IndigoObject.unhighlight</code> method can be applied to a molecule or reaction to dismiss the highlighting on the whole molecule or reaction. You can check if object is highlighted using <code>IndigoObject.isHighlighted</code> method.</p>

<p>The following example shows how to highlight the matched atoms and bonds on a substructure matcher's target, along with explicit hydrogens attached to the matched atoms.</p>

<p>Java:</p>

<pre><code>IndigoObject matcher = indigo.substructureMatcher(target);
IndigoObject match = matcher.match(query);

for (IndigoObject item : query.iterateAtoms())
{
   IndigoObject atom = match.mapAtom(item);
   atom.highlight();

   for (IndigoObject nei : atom.iterateNeighbors())
   {
      if (!nei.isPseudoatom() &amp;&amp; !nei.isRSite() &amp;&amp; nei.atomicNumber() == 1)
      {
         nei.highlight();
         nei.bond().highlight();
      }
   }
}

for (IndigoObject bond : query.iterateBonds())
   match.mapBond(bond).highlight();

System.out.println(target.smiles());
target.unhighlight();
System.out.println(target.smiles());
</code></pre>

<p>C#:</p>

<pre><code>IndigoObject matcher = indigo.substructureMatcher(target);
IndigoObject match = matcher.match(query);

foreach (IndigoObject qatom in query.iterateAtoms())
{
   IndigoObject atom = match.mapAtom(qatom);
   atom.highlight();

   foreach (IndigoObject nei in atom.iterateNeighbors())
   {
      if (!nei.isPseudoatom() &amp;&amp; !nei.isRSite() &amp;&amp; nei.atomicNumber() == 1)
      {
         nei.highlight();
         nei.bond().highlight();
      }
   }
}

foreach (IndigoObject bond in query.iterateBonds())
   match.mapBond(bond).highlight();

System.Console.WriteLine(target.smiles());
target.unhighlight();
System.Console.WriteLine(target.smiles());
</code></pre>

<p>Python:</p>

<pre><code>matcher = indigo.substructureMatcher(target)
match = matcher.match(query)

for qatom in query.iterateAtoms():
  atom = match.mapAtom(qatom)
  atom.highlight()

  for nei in atom.iterateNeighbors():
    if not nei.isPseudoatom() and not nei.isRSite() and nei.atomicNumber() == 1:
      nei.highlight()
      nei.bond().highlight()

for bond in query.iterateBonds():
  match.mapBond(bond).highlight()

print target.smiles()
target.unhighlight()
print target.smiles()
</code></pre>

<h2 id="serialization">Serialization</h2>

<p>You can use the <code>IndigoObject.serialize</code> method to serialize a molecule or a reaction into a binary byte array. All molecule and reaction features are serialized, including atom coordinates, stereochemistry, bond orientations, highlighting, AAM numbers, etc. To restore the molecule/reaction back, use the <code>Indigo.unzerialize</code> method.</p>

<ul>
<li><strong>Note:</strong> groups are not serialized (i.e. polymer brackets and data s-groups will be lost during serialization)</li>
<li><strong>Note:</strong> Molecule/reaction name and SDF properties ate not serialized</li>
</ul>

<p>Java, C#:</p>

<pre><code>byte[] data = mol.serialize();
...
IndigoObject mol2 = indigo.unserialize(data);
</code></pre>

<p>Python: the same with the <code>IndigoObject</code> omitted.</p>

<h2 id="alignment-of-atoms">Alignment of Atoms</h2>

<p>The <code>IndigoObject.alignAtoms</code> method can be used to calculate and apply the transformation (scale + rotatation + translation) of a molecule so that some subset of its atoms will become as close as possible to the desired positions. The method accepts an integer array of atom indices and a float array of desired coordinates (three times bigger that the array of indices, storing resired x,y,z coordinates for each atom).</p>

<p>Java:</p>

<pre><code>  IndigoObject query = indigo.loadSmarts("[#7]1~[#6]~[#6]~[#7]~[#6]~[#6]2~[#6]~[#6]~[#6]~[#6]~[#6]~1~2");
  int[] atoms = new int[query.countAtoms()];
  float[] xyz = new float[query.countAtoms() * 3];

  for (IndigoObject structure : indigo.iterateSDFile("structures.sdf.gz"))
  {
     IndigoObject match = indigo.substructureMatcher(structure).match(query);
     int i = 0;

     if (structure.index() == 0)
        for (IndigoObject atom : query.iterateAtoms())
           System.arraycopy(match.mapAtom(atom).xyz(), 0, xyz, i++ * 3, 3);
     else
     {
        for (IndigoObject atom : query.iterateAtoms())
           atoms[i++] = match.mapAtom(atom).index();

        structure.alignAtoms(atoms, xyz);
     }
  }
</code></pre>

<p>C#:</p>

<pre><code>IndigoObject query = indigo.loadSmarts("[#7]1~[#6]~[#6]~[#7]~[#6]~[#6]2~[#6]~[#6]~[#6]~[#6]~[#6]~1~2");
int[] atoms = new int[query.countAtoms()];
float[] xyz = new float[query.countAtoms() * 3];

foreach (IndigoObject structure in indigo.iterateSDFile("structures.sdf.gz"))
{
   IndigoObject match = indigo.substructureMatcher(structure).match(query);
   int i = 0;

   if (structure.index() == 0)
      foreach (IndigoObject atom in query.iterateAtoms())
         Array.Copy(match.mapAtom(atom).xyz(), 0, xyz, i++ * 3, 3);
   else
   {
      foreach (IndigoObject atom in query.iterateAtoms())
      atoms[i++] = match.mapAtom(atom).index();

      structure.alignAtoms(atoms, xyz);
   }
}
</code></pre>

<p>Python:</p>

<pre><code>query = indigo.loadSmarts("[#7]1~[#6]~[#6]~[#7]~[#6]~[#6]2~[#6]~[#6]~[#6]~[#6]~[#6]~1~2");
xyz = []
for structure in indigo.iterateSDFile("structures.sdf.gz"):
  match = indigo.substructureMatcher(structure).match(query)
  if structure.index() == 0:
    for atom in query.iterateAtoms():
      xyz.extend(match.mapAtom(atom).xyz())
  else:
    atoms = []
    for atom in query.iterateAtoms():
      atoms.append(match.mapAtom(atom).index())
    structure.alignAtoms(atoms, xyz);
</code></pre>

<h2 id="scaffold-detection">Scaffold Detection</h2>

<p>The <code>Indigo.extractCommonScaffold(mode [max_iterations])</code> method searches MCS scaffold for given molecules array and returns an extraction result. The method accepts a string parameter called <code>mode</code>. The following modes are available:</p>

<ul>
<li><code>exact</code> : searches MCS using the exact algorithm.</li>
<li><code>approx</code> : searches MCS using the approximate algorithm</li>
</ul>

<p>There is an optional integer parameter (iteration limit) followed by the mode. The default value for the exact algorithm is 0 (infinite) and for the approximate algorithm is 1000.</p>

<p>Indigo searches MCS in terms of a largest induced molecule1 subgraph isomorphic to an induced molecule2 subgraph. Largest means that a result subgraph can not be extended by the adding a vertex (atom). E.g. there are three possible mcs for the molecules 'NCOCCCS' and 'NCCOCCS' which can not be extended: 'CCOC', 'NC' and 'CCS'.  Indigo stores all the intermediate subgraphs, which can be a result MCS. Thus, after a searching is finished, there is an array (all the solutions) of submolecules available. In the end, the result molecules array is sorted by the following rule: maximize rings number; if two molecules contain equal ring number, then maximize bonds number. The result sorted molecules array (all the maximum common submolecules) can be iterated by the <code>allScaffolds()</code> method. The <code>IndigoObject.allScaffolds()</code> method returns an array object.</p>

<p>Java:</p>

<pre><code>  IndigoObject arr = indigo.createArray();

  for (IndigoObject item : indigo.iterateSDFile("structures.sdf"))
     arr.arrayAdd(item);

  IndigoObject scaf = indigo.extractCommonScaffold(arr, "exact");

  if (scaf != null) {
    System.out.println("max scaffold: " + scaf.smiles());
    for(IndigoObject scaffold: scaf.allScaffolds().iterateArray()) 
       System.out.println("current scaffold: " + scaffold.smiles());
  }
</code></pre>

<p>C#:</p>

<pre><code>  IndigoObject arr = indigo.createArray();

  foreach (IndigoObject item in indigo.iterateSDFile("structures.sdf"))
     arr.arrayAdd(item);

  IndigoObject scaf = indigo.extractCommonScaffold(arr, "approx 2000");

  if (scaf != null) {
    System.Console.WriteLine("max scaffold: " + scaf.smiles());
    for(IndigoObject scaffold: scaf.allScaffolds().iterateArray()) 
       System.Console.WriteLine("current scaffold: " + scaffold.smiles());
  }
</code></pre>

<p>Python:</p>

<pre><code>  arr = indigo.createArray();

  for item in indigo.iterateSDFile("structures.sdf"):
     arr.arrayAdd(item);

  scaf = indigo.extractCommonScaffold(arr, "exact 1000");

  if scaf:
    print "max scaffold:" + scaf.smiles()

    for scaffold in scaf.allScaffolds().iterateArray():
      print "current scaffold:" + scaffold.smiles()
</code></pre>

<h2 id="rgroup-decomposition">R-Group Decomposition</h2>

<p>The R-Group decomposition algorithm separates given molecule into a scaffold (matches the given query molecule) and R-Groups. To start working with the algorithm you need to create a <code>Decomposer</code> object. The <code>Indigo.createDecomposer</code> method accepts a query molecule and returns the <code>Decomposer</code> object. During a decomposition the <code>Decomposer</code> object builds a common scaffold with all R-Groups gathered together(so named <code>full scaffold</code>). The scaffold matches every passed molecule and together with calculated R-Groups restores initial molecules. 
Once the <code>Decomposer</code> object is created, you can pass molecules into and perform the decomposition. The method <code>IndigoObject.decomposeMolecule</code> returns a <code>DecompositionItem</code> object. The method accepts molecule. User can get the calculated results by accessing the <code>DecompositionItem</code> object.
The following methods are used to get the results:</p>

<p>The <code>IndigoObject.decomposedMoleculeWithRGroups</code> returns molecule separated into a scaffold with R-Groups (<code>DecompositionItem</code> object).
The <code>IndigoObject.decomposedMoleculeHighlighte</code> returns molecule with a highlighted scaffold (<code>DecompositionItem</code> object).
The <code>IndigoObject.decomposedMoleculeScaffold</code> returns the full scaffold (<code>Decomposer</code> object) or a submolecule which matches the given query (<code>DecompositionItem</code> object).</p>

<p>Java, C#:</p>

<pre><code>  IndigoObject deco = indigo.createDecomposer(scaf);

  IndigoObject deco_item1 = decomposer.decomposeMolecule(mol1);
  deco_item1.decomposedMoleculeWithRGroups().saveMolfile("molrgoups1.mol");
  deco_item1.decomposedMoleculeHighlighted().saveMolfile("highlighted1.mol");
  deco_item1.decomposedMoleculeScaffold().saveMolfile("scaffold1.mol");

  IndigoObject deco_item2 = decomposer.decomposeMolecule(mol2);
  deco_item2.decomposedMoleculeWithRGroups().saveMolfile("molrgoups2.mol");
  deco_item2.decomposedMoleculeHighlighted().saveMolfile("highlighted2.mol");
  deco_item2.decomposedMoleculeScaffold().saveMolfile("scaffold2.mol");

  IndigoObject scaffold = deco.decomposedMoleculeScaffold();
  scaffold.saveMolfile("full_scaffold.mol");
</code></pre>

<p>Python:</p>

<pre><code>  deco = indigo.createDecomposer(scaf);

  deco_item1 = decomposer.decomposeMolecule(mol1);
  deco_item1.decomposedMoleculeWithRGroups().saveMolfile("molrgoups1.mol");
  deco_item1.decomposedMoleculeHighlighted().saveMolfile("highlighted1.mol");
  deco_item1.decomposedMoleculeScaffold().saveMolfile("scaffold1.mol");

  deco_item2 = decomposer.decomposeMolecule(mol2);
  deco_item2.decomposedMoleculeWithRGroups().saveMolfile("molrgoups2.mol");
  deco_item2.decomposedMoleculeHighlighted().saveMolfile("highlighted2.mol");
  deco_item2.decomposedMoleculeScaffold().saveMolfile("scaffold2.mol");

  scaffold = deco.decomposedMoleculeScaffold();
  scaffold.saveMolfile("full_scaffold.mol");
</code></pre>

<p><strong>Note</strong>: There are possible situations when a given query molecule does not match a next decomposition molecule. An exception is raised in that case.</p>

<p>The <code>DecompositionItem</code> objects supports iterating matches since a given query scaffold can have several embeddings. The <code>IndigoObject.iterateDecompositions</code> returns the <code>DecompositionItem</code> iterator. The full scaffold can be completed by an appropriate match. The <code>IndigoObject.addDecomposition</code> (<code>Decomposer</code> object )method accepts a <code>DecompositionItem</code> object and adds the current match to the full scaffold. The following example shows the usage with iterating all matches:</p>

<p>Python:</p>

<pre><code>  ...

  # iterate over all the structures
  for smiles in structures:
     # handle current molecule and handle exceptions
     try:
        item = deco.decomposeMolecule(indigo.loadMolecule(smiles))
        # iterate over all the decompositions
        for q_match in item.iterateDecompositions()
           # get decomposed molecules (current match)
           rg_mol = q_match.decomposedMoleculeWithRGroups()
           # add current match
           deco.addDecomposition(q_match)

     except Exception,e:
        # error handlers
</code></pre>

<p><strong>Note</strong>: There are two different types of input queries:
 - user defined molecule with RGroups 
 - simple query molecule, which can be passed from the Scaffold Detection</p>

<p>In the first case the full scaffold equals to the user defined molecule itself and it can not be changed during the RGroup Decomposition. In the second case the full scaffold should be generated by the library, and it will be returned by the <code>decomposedMoleculeScaffold</code> method. You can load scaffold from a molfile. The SMILES format is not supported at the moment.</p>

<p>The following example shows the usage  user-defined scaffold:</p>

<p>Python:</p>

<pre><code>  # prepate query scaffold (e.g. '(R1)C1CCCC(R2)C1')
  scaffold = indigo.loadQueryMoleculeFromFile("query_mol")

  # init decomposition
  deco = indigo.createDecomposer(scaffold)

  # load molecule
  mol = indigo.loadMolecule('NC1CCCC(O)C1')

  # create deco item
  item = deco.decomposeMolecule(indigo.loadMolecule(smiles))

  # iterate over all the decompositions
  for q_match in item.iterateDecompositions()
     # get decomposed molecule (current match)
     rg_mol = q_match.decomposedMoleculeWithRGroups()

     # print molfile
     print(rg_mol.molfile())
</code></pre>

<p>In the example above there will be two matches:
(R1)C1CCCC(R2)C1, R1=OH, R2=NH2
(R1)C1CCCC(R2)C1, R1=NH2, R2=OH </p>

<p><strong>Note</strong>: the following code is deprecated:</p>

<p>Java:</p>

<pre><code>  IndigoObject deco = indigo.decomposeMolecules(scaf, arr);
  deco.decomposedMoleculeHighlighted().saveMolfile("highlighted.mol");
  IndigoObject scaffold = deco.decomposedMoleculeScaffold();
  for (IndigoObject item : deco.iterateDecomposedMolecules())
     System.out.println(item.decomposedMoleculeWithRGroups().molfile());
</code></pre>

<p>C#:</p>

<pre><code>  IndigoObject deco = indigo.decomposeMolecules(scaf, arr);
  deco.decomposedMoleculeHighlighted().saveMolfile("highlighted.mol");
  IndigoObject scaffold = deco.decomposedMoleculeScaffold();
  foreach (IndigoObject item in deco.iterateDecomposedMolecules())
     System.Console.WriteLine(item.decomposedMoleculeWithRGroups().molfile());
</code></pre>

<p>Python:</p>

<pre><code>  deco = indigo.decomposeMolecules(scaf, arr);
  deco.decomposedMoleculeHighlighted().saveMolfile("highlighted.mol");
  scaffold = deco.decomposedMoleculeScaffold();
  for item in deco.iterateDecomposedMolecules():
     print item.decomposedMoleculeWithRGroups().molfile()
</code></pre>

<h2 id="reaction-products-enumeration">Reaction Products Enumeration</h2>

<p>Java:</p>

<pre><code>  IndigoObject reaction = indigo.loadQueryReactionFromFile(rxn_path);
  IndigoObject monomers_table = indigo.createArray();
  for (int i = 0; i &lt; reaction.countReactants(); i++)
  {
     monomers_table.arrayAdd(indigo.createArray());

     for (IndigoObject iterr : indigo.iterateSDFile(mon_paths[i])
     {
        monomers_table.at(i).arrayAdd(iterr.clone());
     }
  }
  IndigoObject output_reactions = indigo.reactionProductEnumerate(reaction, monomers_table);
</code></pre>

<h2 id="reactionbased-molecule-transformations">Reaction-based Molecule Transformations</h2>

<p>Examples of usage are avialible <a href="../concepts/transformation.html">here</a>.</p>

<p>Java:</p>

<pre><code>  IndigoObject reaction = indigo.loadQueryReaction("[NH:3]=[N:1]#[N:2]&gt;&gt;[NH:3]=[N+:1]=[#7-:2]");
  IndigoObject molecule = indigo.loadMolecule("N#N=NC1=CC(=CC=C1)N=N#N");
  indigo.transform(reaction, molecule);
  System.out.println(molecule.smiles); // N(C1=CC=CC(N=[N+]=[N-])=C1)=[N+]=[N-]
</code></pre>

<h2 id="rendering">Rendering</h2>

<p>Rending in Indigo is done by the <code>IndigoRenderer</code> plugin which is included
in the Indigo distribution. The plugin is available for C (as a separate
dynamic library), and has wrappers for all supported languages.<br>
</p>

<p>To work with the rendering plugin in C#/Java/Python wrappers,
one needs to create an instance of <code>IndigoRenderer</code>, passing
an existing <code>Indigo</code> instance to it.</p>

<p>Java and C#:</p>

<pre><code>IndigoRenderer renderer = new IndigoRenderer(indigo);
</code></pre>

<p>A large number of <a href="options.html#rendering">options</a> 
can be set for the rendering plugin. They are set via
the ordinary <code>Indigo</code> instance.
One of the options is obligatory: <code>render-output-format</code>
tells which format the image should be rendered to.</p>

<p>The <code>IndigoRenderer.renderToBuffer</code> accepts an <code>IndigoObject</code> and
returns a byte buffer with PNG, SVG, or PDF image (on the Windows
platform, EMF format is supported too).
Similarly, the <code>IndigoRenderer.renderToFile</code> method saves the image to a file.</p>

<p>Java and C#:</p>

<pre><code>indigo.setOption("render-output-format", "png");
indigo.setOption("render-margins", 10, 10);
mol1.layout();
indigo.setOption("render-comment", "N-Hydroxyaniline")
renderer.renderToFile(mol1, "mol.png");

indigo.setOption("render-output-format", "svg");
byte[] svg = renderer.renderToBuffer(rxn);
</code></pre>

<p>Python: the same with the <code>byte[]</code> omitted.</p>

<h3 id="rendering-multiple-items-to-grid">Rendering Multiple Items to Grid</h3>

<p><code>IndigoRenderer.renderGridToFile</code> and <code>IndigoRenderer.renderGridToBuffer</code> methods can be used to render multiple molecules or reactions at once. The rendered items are placed in grid specified by its number of columns. Some <a href="options.html#rendering-in-grid">options</a> are available for placing titles under (or above) the items.</p>

<p>Java:</p>

<pre><code>IndigoObject arr = indigo.createArray();

for (IndigoObject item : indigo.iterateSDFile("structures.sdf"))
   arr.arrayAdd(item);

renderer.renderGridToFile(collection, null, 4, "structures.png");
</code></pre>

<p>C#:</p>

<pre><code>IndigoObject arr = indigo.createArray();

foreach (IndigoObject item in indigo.iterateSDFile("structures.sdf"))
   arr.arrayAdd(item);

renderer.renderGridToFile(collection, null, 4, "structures.png");
</code></pre>

<p>Python:</p>

<pre><code>arr = indigo.createArray();

for item in indigo.iterateSDFile("structures.sdf"):
   arr.arrayAdd(item);

renderer.renderGridToFile(collection, None, 4, "structures.png")
</code></pre>

<p>The second parameter of the <code>IndigoRenderer.renderGridToFile</code> and <code>IndigoRenderer.renderGridToBuffer</code> methods is optional. You can specify it only for molecules, not for reactions. If this parameter is not <code>null</code>, it has to be an integer array whose number of elements is equal to the number of given molecules. Each element of this array is the index of the "referene atom" in the corresponding molecule. The rendering is then done in such a way that the reference atoms are grid-aligned. You can see the examples of this at <a href="http://ctr.wikia.com/wiki/Align_the_depiction_using_a_fixed_substructure">CTR</a>. </p>

<h3 id="win32-and-net-support">Win32 and .NET Support</h3>

<p>In the .NET API, additional <code>IndigoRenderer</code> methods are available for working with Win32 HDC and <code>System.Drawing</code> objects directly:</p>

<ul>
<li><code>void renderToHDC (IndigoObject item, IntPtr hdc, bool printing)</code></li>
<li><code>Bitmap renderToBitmap (IndigoObject item)</code></li>
<li><code>Metafile renderToMetafile (IndigoObject item)</code></li>
</ul>

<h2 id="inchi">InChI</h2>

<p>InChI support is done via IndigoInchi plugin. To work with the InChI plugin in C#/Java/Python wrappers, one needs to create an instance of IndigoInchi, passing an existing Indigo instance to it.</p>

<p>Use <code>IndigoInchi.loadMolecule</code> method to convert InChI strings to a molecule, and <code>IndigoInchi.getInchi</code> method for the reverse operation.</p>

<p>Python:</p>

<pre><code>indigo_inchi = IndigoInchi(indigo);

print(indigo_inchi.version())
m = indigo_inchi.loadMolecule("InChI=1S/C10H20N2O2/c11-7-1-5-2-8(12)10(14)4-6(5)3-9(7)13/h5-10,13-14H,1-4,11-12H2")
print(m.canonicalSmiles())
print(indigo_inchi.getInchi(m))
print(indigo_inchi.getWarning())

m = indigo.loadMolecule("C1CCCCCCC1")
print(indigo_inchi.getInchi(m))
</code></pre>

<h3 id="options">Options</h3>

<p>You can pass any options supported by the official InChI library via <code>inchi-options</code> option:</p>

<pre><code>indigo.setOption("inchi-options", "/DoNotAddH /SUU /SLUUD")
</code></pre>

<p>One can use both <code>-</code> and <code>/</code> prefix for them:</p>

<pre><code>indigo.setOption("inchi-options", "-DoNotAddH /SUU -SLUUD")
</code></pre>